import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { TransactionLogAnalytics } from '@/components/admin/TransactionLogAnalytics';

// Mock the hooks
jest.mock('@/hooks/use-toast', () => ({
  useToast: () => ({
    toast: jest.fn(),
  }),
}));

// Mock fetch
const mockFetch = jest.fn();
global.fetch = mockFetch;

describe('TransactionLogAnalytics', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockFetch.mockClear();
    
    // Mock users fetch response
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: async () => ({
        data: [
          {
            id: 'user-1',
            first_name: 'John',
            last_name: 'Doe',
            email: 'john@example.com',
            role: 'user',
          },
          {
            id: 'user-2',
            first_name: 'Jane',
            last_name: 'Smith',
            email: 'jane@example.com',
            role: 'user',
          },
        ],
      }),
    });
  });

  it('should render transaction log analytics component', async () => {
    render(<TransactionLogAnalytics />);

    expect(screen.getByText(/Select User for Error Summary/i)).toBeInTheDocument();
    expect(screen.getByText(/AI-Powered Error Summary/i)).toBeInTheDocument();
    
    await waitFor(() => {
      expect(screen.getByText(/Select a user/i)).toBeInTheDocument();
    });
  });

  it('should load users in dropdown', async () => {
    render(<TransactionLogAnalytics />);

    await waitFor(() => {
      expect(mockFetch).toHaveBeenCalledWith(
        'http://localhost:3000/api/auth/users',
        expect.objectContaining({
          headers: expect.objectContaining({
            'Authorization': expect.stringContaining('Bearer'),
          }),
        })
      );
    });
  });

  it('should handle user selection', async () => {
    const user = userEvent.setup();
    render(<TransactionLogAnalytics />);

    await waitFor(() => {
      const selectTrigger = screen.getByRole('combobox');
      expect(selectTrigger).toBeInTheDocument();
    });

    // Click on the select dropdown
    const selectTrigger = screen.getByRole('combobox');
    await user.click(selectTrigger);
  });

  it('should handle error summary generation', async () => {
    const user = userEvent.setup();
    
    // Mock error summary response
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: async () => ({
        success: true,
        data: {
          summary: 'Test error summary generated by AI',
        },
        message: 'Error summary fetched',
      }),
    });

    render(<TransactionLogAnalytics />);

    await waitFor(() => {
      const button = screen.getByText(/Get Error Summary/i);
      expect(button).toBeInTheDocument();
    });

    // Button should be disabled when no user is selected
    const button = screen.getByText(/Get Error Summary/i);
    expect(button).toBeDisabled();
  });

  it('should display error summary when generated', async () => {
    const user = userEvent.setup();
    
    // Mock successful error summary response
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: async () => ({
        success: true,
        data: {
          summary: 'You have encountered multiple investment errors including insufficient balance and exceeding limits.',
        },
        message: 'Error summary generated successfully',
      }),
    });

    render(<TransactionLogAnalytics />);

    // Wait for component to load
    await waitFor(() => {
      expect(screen.getByText(/No error summary available/i)).toBeInTheDocument();
    });
  });

  it('should handle clear selection', async () => {
    const user = userEvent.setup();
    render(<TransactionLogAnalytics />);

    await waitFor(() => {
      const clearButton = screen.getByText(/Clear Selection/i);
      expect(clearButton).toBeInTheDocument();
    });

    const clearButton = screen.getByText(/Clear Selection/i);
    await user.click(clearButton);
  });

  it('should show selected user details', async () => {
    render(<TransactionLogAnalytics />);

    await waitFor(() => {
      // Should not show user details initially
      expect(screen.queryByText(/Selected User Details/i)).not.toBeInTheDocument();
    });
  });
});